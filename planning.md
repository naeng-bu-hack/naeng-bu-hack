# 기획

<aside>
💡

내 냉장고에 있는 식재료로 요리를 만든다

</aside>

[GPT가 정리해준거](https://www.notion.so/GPT-314b3ecbc1e580cdb637d3fa191e6d4b?pvs=21)

# **Product Vision**

## **문제 정의**

사용자는 다음 문제를 겪는다: 

- 냉장고에 뭐가 있는지는 안다.
- 하지만 “이걸로 뭘 해먹지?”에서 멈춘다.
- 기존 레시피 앱은 “요리명 검색 → 재료 확인” 구조다.
- 우리는 “재료 입력 → 요리 추천” 구조를 만든다.

## **제품의 본질**

> 냉장고 상태 기반 요리 코칭 시스템
> 

단순 레시피 추천이 아니라:

- 냉장고 상태 해석
- 제약 조건 기반 추천
- 예능형 인터랙션
- 공유 가능한 결과물 생성

# **Product Goals**

## **단기 목표 (MVP)**

- 재료 커버리지 기반 레시피 추천
- 냉부해 스타일 대본 출력
- 공유 카드 생성
- Web 기반 배포 (PWA)

## **중기 목표**

- 재료 ontology 고도화
- 벡터 기반 검색
- 개인화 추천
- 사진 기반 재료 인식 (실험적)

# **전체 사용자 플로우**

## 1. 진입

앱 / 웹 접속

## 2. 재료 입력

### **입력 방식**

1. 🎙️ 보이스 입력 
2. ⌨️ 텍스트 입력 
3. 📷 사진 입력 

### **내부 처리 흐름**

1. 음성, 사진 → 텍스트 변환
2. 재료 엔티티 추출
3. 재료 정규화
4. 사용자 수정 (HITL)

## **3. 요리 방향 설정**

사용자는 선택:

- 음식 종류 (한식/양식/중식/일식/무관)
- 조리 시간 제한
- 셰프 스타일

## **4. 레시피 탐색**

시스템은:

1. 레시피 DB에서 후보 탐색
2. 재료 커버리지 계산
3. 점수 기반 랭킹
4. 상위 3개 반환

## **5. 결과 출력**

### **구조적 레시피 정보**

- 요리 이름
- 사용 재료
- 없는 재료
- 조리 단계
- 시간/난이도
- (가능하면) 유튜브 링크

### **냉부해 스타일 대본**

- LLM을 이용해 구조적 레시피를 예능형 대본으로 변환
- 사용자 맘에 안들면, 다른 레시피로 넘어가는 로직도 있으면 좋음 (HITL 인지는 모르겠지만)

## **6. 요리 완료**

- 완성 사진 업로드
- 한 줄 후기 작성

## **7. 공유 카드 생성**

자동 생성 이미지:

- Before: 재료 목록
- After: 완성 요리
- 사용한 재료 수
- 추가 구매 여부

인스타 스토리 규격으로 생성.

# **테스크 (PRD-style / 팀 분배용 상세 버전)**

> 원칙: 각 테스크는
> 
> 
> **독립적으로 개발/검증 가능**
> 
> **Mock**
> 

---

## **Task A — PWA Frontend (사용자 플로우 구현)**

### **목적 / 목표**

이 테스크의 목표는 “앱이 실제로 돌아간다”는 감각을 주는 **엔드유저 경험(UX) 뼈대**를 만드는 것이다. 즉, 백엔드가 완성되지 않았더라도 사용자는 PWA에서 재료 입력 → 조건 선택 → 결과 확인 → 공유 카드 확인까지 “끝까지” 따라갈 수 있어야 한다. 초기 MVP의 프론트는 기능의 완성도보다 **흐름의 완결성**이 중요하다.

### **Input / Output**

- **Input**: (1) 재료 입력(텍스트/보이스 결과 텍스트), (2) 요리 방향 설정 값, (3) 결과 API 응답(JSON)
- **Output**: (1) 사용자에게 보여지는 UI 화면들, (2) 공유 카드 생성 요청/표시, (3) 선택/수정 이벤트 로그(선택)

프론트에서 다루는 “정규화된 재료 리스트”는 아래 형태를 표준으로 한다:

```
{
  "ingredients": [
    { "name_raw": "김치", "normalized_id": "kimchi", "quantity": "1통", "confidence": 0.9 }
  ]
}
```

### **하드 포인트**

- 모바일 뷰포트 최적화(냉장고 앞에서 쓰는 상황 가정)
- “HITL 수정 UX”의 사용성: AI가 뽑은 재료를 **10초 안에 수정**할 수 있는 UI
- 로딩 화면/상호작용(다른 레시피, 더 쉬운 버전) 설계
- 공유 카드 화면을 “저장/공유하기”까지 자연스럽게 연결

### **Mock 전략**

- API가 없어도 동작하도록 **Mock JSON**을 프론트에 내장한다.
- /api/ingredients/parse, /api/recipes/recommend, /api/script/generate, /api/share/render 각각에 대해 “고정 응답”을 준비하고, 환경 변수(DEV_MOCK=true)로 전환한다.

### **Dependency**

- 원칙적으로 **없음**. (백엔드는 전부 Mock 가능)
- 단, 표준 I/O JSON 스키마는 Task F(공통 결정)와 합의가 필요.

### **리스크**

- 프론트가 “보기만 좋은 데모”로 끝나고 실제 통합 시 API 계약이 어긋날 수 있음 → **스키마를 먼저 박아야 함**
- 공유 카드 생성(이미지 렌더)이 늦어질 경우 UX 막힘 → 최소 MVP는 “텍스트 카드 화면”으로 대체 가능

---

## **Task B — Ingredient Input Module (보이스/텍스트 → 재료 리스트)**

### **목적 / 목표**

이 테스크는 사용자가 말하거나 입력한 문장을 **정규화된 재료 리스트로 바꾸는 것**이 목적이다. “인식 정확도 100%”가 목표가 아니다. 목표는 **초안 품질을 충분히 높여서 HITL 수정 비용을 최소화**하는 것이다(=사용자가 빨리 고칠 수 있게).

MVP에서는 “보이스 입력”을 Primary로 가져가되, 실제로는 **ASR 결과 텍스트**를 받아서 처리하는 파이프라인까지 포함한다.

### **Input / Output**

- **Input A (보이스)**: audio blob 또는 audio stream
- **Input B (텍스트)**: "김치 한 통, 계란 여섯 개, 대파 조금"
- **Output**: 정규화된 재료 리스트 + 각 항목의 confidence + 원문 토큰 정보(선택)

권장 Output:

```
{
  "utterance": "김치 한 통, 계란 여섯 개",
  "ingredients": [
    { "name_raw": "김치", "normalized_id": "kimchi", "quantity": "1통", "confidence": 0.92 },
    { "name_raw": "계란", "normalized_id": "egg", "quantity": "6개", "confidence": 0.95 }
  ],
  "unknown_chunks": ["반찬 좀", "야채 조금"]
}
```

### **하드 포인트**

- **단위/수량 처리**: “조금/한 줌/반 통/두 스푼” 등 비정형 표현을 다뤄야 함.
- **동의어/표기 흔들림**: “대파/파/쪽파”, “삼겹살/돼지고기”, “진간장/간장”
- **한국어 음식 재료의 다양성**: 반찬명(깻잎무침, 장조림) 같은 고유명사
- **ASR 오인식 후처리**: “계란”→“계산” 같은 오류 교정은 완벽하지 않아도 되지만, 최소한 “수정하기 쉬운” 형태로 내보내야 함.

### **Mock 전략**

- ASR은 MVP에서 실제 연동이 어려우면 audio -> fixed transcript로 Mock 처리 가능.
- Normalizer는 초기엔 **정적 매핑 JSON**(동의어 사전) + 규칙 기반(단위 제거)로 충분.
- “confidence”는 실제 모델이 없으면 규칙 기반 점수로 대체.

### **Dependency**

- Recipe DB와는 **완전 분리**. (normalized_id만 공유)
- 다만 normalized_id의 표준(ontology)은 팀 공통 결정 사항(Task F)로 합의 필요.

### **리스크**

- 여기서 품질이 낮으면 사용자가 수정에 지쳐서 앱이 끝남 → HITL UX와 함께 설계되어야 함.
- ontology를 너무 욕심내면 시간이 다 빨림 → MVP는 “자주 나오는 재료 200개” 같은 스코프로 제한 권장.

---

## **Task C — Recipe Retrieval Engine (재료 리스트 → 레시피 후보 3개)**

### **목적 / 목표**

이 테스크의 목표는 “사용자가 가진 재료로 만들 수 있는 레시피”를 **합리적인 근거로 3개 추천**하는 것이다. 핵심은 “벡터DB”가 아니라 **커버리지 기반 추천의 일관성**이다. 심사/데모에서 중요한 건 “왜 이 레시피가 나왔는지” 설명 가능해야 한다.

MVP에서는 온라인 크롤링/실시간 검색이 아니라 **고정 레시피 DB**로 안정성을 확보한다.

### **Input / Output**

- **Input**: 정규화된 재료 리스트 + 선호 조건(음식 종류/시간/난이도/셰프 스타일)
- **Output**: 추천 레시피 배열(상위 3개) + 각 레시피의 스코어 분해 + 부족 재료

권장 Output:

```
{
  "candidates": [
    {
      "recipe_id": "r_1023",
      "title": "김치돼지볶음",
      "used": ["kimchi", "pork", "onion"],
      "missing": ["gochujang"],
      "score": 0.83,
      "score_breakdown": {
        "coverage": 0.75,
        "time_fit": 1.0,
        "cuisine_fit": 0.8
      },
      "source_url": "...",
      "youtube_url": "..."
    }
  ]
}
```

### **하드 포인트**

- **커버리지 계산**: “있다/없다”가 아니라 핵심재료 가중치가 필요(삼겹살 없는 김치볶음? 가능하지만 품질 떨어짐).
- **대체재 제안**: “고추장 없으면 간장+설탕으로 대체” 같은 룰 기반 대체는 강력한 UX 개선.
- **랭킹 튜닝**: 너무 ‘추가 구매 0’만 고집하면 추천이 빈약해지고, 너무 ‘맛’만 고집하면 실제 사용성이 떨어짐.

### **Mock 전략**

- DB 없이도 “항상 같은 3개 레시피” 반환 가능.
- score_breakdown도 고정값으로 만들어 프론트/LLM이 테스트 가능하게 한다.

### **Dependency**

- Ingredient Normalizer의 normalized_id 스펙에만 의존.
- LLM과 Share는 이 Output만 받으면 독립 수행 가능.

### **리스크**

- 레시피 DB 수집이 생각보다 시간이 많이 듦 → MVP는 “30~100개 curated DB”부터 시작.
- 유튜브 링크는 실시간 검색하면 불안정 → MVP는 DB에 “미리 박아둔 링크”로 안정화.

---

## **Task D — LLM Script Generator (구조적 레시피 → 냉부해 대본)**

### **목적 / 목표**

이 테스크는 레시피를 “유용한 정보”로 제공하는 동시에, 제품의 차별점인 “냉부해 스타일”을 만드는 것이다. 단, 예능이 목적이 아니라 **설명력 강화(실패 방지, 요약, 재미)**가 목적이다.

즉, Output은 반드시 “레시피 정보의 손실 없이” 대본을 생성해야 한다.

### **Input / Output**

- **Input**: Retrieval Engine이 반환한 레시피 객체 1개
- **Output**: (1) 구조화된 요약(steps, tips) + (2) 스크립트 텍스트

권장 Output:

```
{
  "recipe_id": "r_1023",
  "structured": {
    "title": "...",
    "steps": ["...", "..."],
    "tips": ["...", "..."]
  },
  "script": "👨‍🍳 A: ...\n👨‍🍳 B: ..."
}
```

### **하드 포인트**

- **환각 방지**: 없는 재료를 추가하거나, DB에 없는 단계를 만들어내면 신뢰 붕괴.
- **구조 유지**: 프론트가 쓰기 쉬운 형식(steps 배열 등)을 유지해야 함.
- **톤 일관성**: 캐릭터(셰프 스타일) 옵션에 따라 말투/진행이 바뀌어야 재밌음.

### **Mock 전략**

- 템플릿 기반으로 “항상 같은 대본” 출력해도 통합 테스트 가능.
- LLM 연결은 Phase 1에서 붙이고, 그 전엔 deterministic 템플릿으로 대체.

### **Dependency**

- Recipe Retrieval Output 스키마에만 의존.
- 프롬프트 템플릿/캐릭터 정의는 팀 공통 결정(Decision 항목) 필요.

### **리스크**

- 재미를 과하게 추구하면 정보성이 떨어짐 → **structured output은 항상 유지**하고 script는 장식으로
- 토큰/비용, latency → 로딩 UX 설계 필요 (프론트와 협업)

---

## **Task E — Share Card Generator (결과/완료 인증 → 공유 이미지)**

### **목적 / 목표**

공유 카드는 “임팩트”를 가장 쉽게 보여주는 장치다. 목표는 인스타 스토리에 바로 올릴 수 있는 형태의 결과물을 만드는 것. MVP에서는 완전 자동보다는 “템플릿에 값 채우기”로 빠르게 간다.

### **Input / Output**

- **Input**: (before 재료 리스트) + (after 레시피/사진 optional) + 한줄평
- **Output**: image/png 또는 image/webp

### **하드 포인트**

- 텍스트 길이 자동 조절(재료가 많아지면 레이아웃 깨짐)
- 이미지 생성 방식 선택(HTML->Canvas, headless chrome, 서버 렌더, 클라 렌더)
- 사진 업로드 시 개인정보/메타데이터 처리(선택)

### **Mock 전략**

- MVP: 이미지 생성 대신 “공유 카드 HTML 화면”만 만들어도 됨(사용자가 스크린샷).
- 그 다음: 서버에서 렌더하여 png 반환.

### **Dependency**

- Recipe/LLM과는 약한 결합(표시용 텍스트만 있으면 됨)

### **리스크**

- 이미지 렌더는 은근히 늪(폰트/줄바꿈/크로스브라우저) → MVP는 스크린샷 전략 추천
- 사진 업로드까지 하면 저장소/보안 이슈 증가 → Phase 2

---

## **Task F — Infra & Contract (Docker 로컬 환경 + API 계약)**

### **목적 / 목표**

팀 개발을 병렬화하려면 “계약”과 “실행 환경”이 먼저 있어야 한다. 이 테스크의 목표는 (1) 로컬에서 전부 띄울 수 있는 docker-compose, (2) API 엔드포인트 정의(OpenAPI), (3) Mock 서버 제공이다.

### **Input / Output**

- **Input**: 팀이 합의한 JSON 스키마/API 목록
- **Output**: docker-compose + backend skeleton + OpenAPI spec + mock server

### **하드 포인트**

- 계약이 흔들리면 전체가 흔들림 → MVP 범위의 endpoint를 최소화해야 함
- 로컬에서 빠르게 띄우는 게 중요(DevEx)

### **Mock 전략**

- mock server는 필수. 실제 모듈 개발 전에도 프론트가 붙을 수 있어야 한다.

### **Dependency**

- 모든 팀원의 공통 기반이므로 가장 먼저 착수해야 함.

### **리스크**

- 스택 논쟁으로 시간 소모 → 아래 “결정해야 하는 사항”에서 빠르게 결론 내야 함.

---

# **결정해야 하는 사항 (팀 공통 합의)**

> 원칙: “미래 확장”보다 “MVP 데모 안정성” 우선. 결정은 늦추면 전부 늦어짐.
> 
> 
> **오늘 합의 가능한 최소 결정**
> 

---

## **1) PWA vs Web vs App**

### **옵션**

- **PWA(Web)**: URL로 바로 테스트/공유 가능. MVP 최적.
- **Native App**: 센서/카메라/마이크 접근은 편하지만 배포/테스트 비용 큼.
- **Web only**: 설치감(홈 화면 추가)이 약하지만 구현 단순.
- **Expo**: 익숙함.

### **권장 결론(현재 맥락)**

- **PWA 우선(MVP)**. 심사/팀 테스트 관점에서 최적.
- App은 Phase 2에서 래핑 가능.

### 결정

- expo로.
    - 팀원 중 세 명이 경험이 있음
    - 사진찍어야 하니 native 있어야함.

---

## **2) 기술 스택 (Frontend/Backend)**

### **결정해야 할 질문**

- 프론트: React/Next? Svelte? Vue?
    - expo + RN
- 백엔드: Python(FastAPI) vs Node(Express/Nest)
    - python + fastapi

---

## **3) 입력 모달리티 우선순위 (보이스/텍스트/사진)**

### **결정해야 할 질문**

- MVP에서 무엇을 “기본 경로”로 삼을 것인가?
- 사진은 MVP에 넣을지, 실험 기능으로 둘지?

### **결론**

- 텍스트를 먼저. 보이스 + 사진은 추가하는걸로
    - llm 콜을 여러번 하는걸로
    - 
- **보이스를 Primary**, 텍스트를 Fallback.
- 사진은 Phase 2(Experimental)로 둔다. (리스크가 크고 데모 실패 포인트)

---

## **4) 레시피 데이터 소스(가장 중요)**

### **결정해야 할 질문**

- 레시피 DB는 어디서 오는가?
    - curated(직접 수집)
    - 크롤링
    - 외부 API
- 유튜브 링크는 실시간 검색인가, DB에 박아두는가?

### **MVP 권장 결론**

- **curated 정적 DB**로 시작(30~100개).
- 링크/유튜브는 DB에 미리 포함(데모 안정성).

---

## **5) 공통 데이터 계약(필수)**

- Ingredient normalized_id의 정의 범위(초기 200개? 500개?)
- Recipe schema(재료 목록, steps, time, difficulty, cuisine)
- API endpoints 최소 집합

이건 Task F에서 OpenAPI로 박아두는 게 가장 안전.

---

# 그래프 기반 정규화 레시피 DB 기획안

## 1. 문제 정의

### 1) 기존 레시피의 구조적 한계

- 자연어 중심의 비정형 데이터
- 재료·도구·시간·난이도가 암묵적으로 표현됨
- 사람이 직접 해석해야 실행 가능

### 2) 선형(Linear) 구조의 비효율

- 대부분 위상 정렬된 단일 순서로 제공
- 실제 요리는 병렬 수행 가능한 태스크가 존재
- 사용자가 직접 병렬 가능 여부를 판단해야 함

### 3) 제약 기반 탐색의 부재

아래와 같은 현실적 제약을 반영한 검색이 어렵다:

- 재료 제약 (있는 재료만 사용 / 특정 재료 제외 / 대체 허용)
- 도구 제약 (전자레인지만, 원팬 요리 등)
- 뒤처리 제약 (설거지 적은 요리, 기름기 적은 요리)
    
    이를 통해:
    
    ---
    
    - 제약 기반 검색

## 2. 해결 방향

레시피를 **그래프 기반 구조 + 정규화된 메타데이터**로 재구성한다.

> 레시피 = 메타데이터 + 태스크 의존성 그래프(DAG)
> 
- 자동 스케줄링
- 난이도/설거지 정량화
- 대체재 적용
    
    이 가능해진다.
    

- 민철 : 전체 인프라 + 프론트 + 공유 이미지 (시간되면)
- 환규 : 프론트 + 구조적 레시피 → 냉부해 스타일 대본

- 도영 : 사용자 입력 → 재료 리스트 추출
- 수빈 : 재료 리스트 → 레시피 추출

사용할 온톨로지 : https://foodkg.github.io/whattomake.html